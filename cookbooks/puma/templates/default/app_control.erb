#!/bin/bash
# Auto-generated by Chef; your changes will be overwritten!

# Pull in a full environment and include some configuration of said commands.

source /etc/profile
source /data/<%= @app_name %>/shared/config/env
source /data/<%= @app_name %>/shared/config/env.custom
source /data/<%= @app_name %>/shared/config/env.cloud

# Ensure that we are running as the root user.
# If not, error exit while notifying the user.

if [[ $(id -u) -eq 0 ]] ; then
  echo "ERROR: This script must be run as a user, not as root." 2>&1
  exit 1
fi

ACTION="$1"
PORT="${2:-$PORT}" # Take port from env var, but allow override with second argument

fetch_current_pid() {
  if [ -z "$PORT" ] ; then
    PORT=$baseport
  fi
  pidfile="${pid_directory}/puma.$PORT.pid"

  if [[ -s "$pidfile" ]] ; then
    current_pid=$(cat "$pidfile")
    process_count=`ps -p ${current_pid} -o comm= | wc -w`
    if [[ $process_count = "0" ]]; then
      # Remove the pidfile if the process isn't actually running
      current_pid=0
      cleanup
    fi
  else
    # Try to check if the process is running - if found, provide missing pid file
    current_pid="$(ps auwwx | grep ".*[Pp]uma\.${PORT}\.pid.*--port ${PORT}" | awk '{print $2}')"
    process_count=`echo $current_pid | wc -w`
    if [[ $process_count = "1" ]]; then
      current_release_dir="$(readlink $current_path)"
      existing_proc_dir="$(readlink /proc/$current_pid/cwd)"

      if [[ "$current_release_dir" != "$existing_proc_dir" ]]; then
        logger "Killing $current_pid because it is running from $existing_proc_dir, not $current_release_dir"
        # NOT a previously running copy of this app -- kill it because its squating on the port
        kill -9 $current_pid
        current_pid=0
        # TODO: Clean up associated files in the /var/run directory
      else
        echo $current_pid > $pidfile
      fi
    else
      current_pid=0
    fi
  fi

  return 0
}

is_running() {
  fetch_current_pid
  if [[ ${current_pid} == 0 ]] ; then
    return 1
  fi

  if [[ -d "/proc/${current_pid}" ]] ; then
    application_name=${application}
    process_name="$(readlink /proc/$current_pid/exe)"
    process_dir="$((cat /proc/${current_pid}/environ; echo) | tr '\000' '\n' | grep '^PWD=' |sed -e 's/PWD=//')"
  fi
  return 0
}

cleanup() {
  if [ -z "$PORT" ] ; then
    PORT=$baseport
  fi
  pidfile="${pid_directory}/puma.$PORT.pid"

  if [[ -s "$pidfile" ]] ; then
    echo "Cleaning up pid and socket files"
    rm $pidfile
    rm ${pid_directory}/puma.$PORT.state
    rm ${pid_directory}/pumactl.$PORT.sock
  fi
  return 0
}

status() {
  if is_running ; then
    echo "Puma is running on port $PORT with:"
    echo "  pid: $current_pid"
    echo "  name: $process_name"
    echo "  cwd: $process_dir"
    cd ${current_path}
    pumactl -S ${pid_directory}/puma.$PORT.state stats
  else
    echo "Puma is not running on port $PORT."
  fi
}

start() {
  if is_running ; then
    echo "ERROR: Puma already running on port $PORT with: "
    echo "  pid: $current_pid "
    echo "  name: $process_name "
    echo "  cwd: $process_dir"
    exit 1
  fi

  if [ -d "${current_path}" ]; then
    if [ ! -z "$PORT" ] ; then
      echo "Puma is being started for $application port $PORT ..."
      cd ${current_path}

      # Don't need to use bundler because bundle_stubs is the first entry in the PATH
      nohup puma ${threads:+"-t $threads"} \
        --environment ${framework_env} \
        --state ${pid_directory}/puma.$PORT.state \
        --control unix://${pid_directory}/pumactl.$PORT.sock \
        --pidfile ${pid_directory}/puma.$PORT.pid \
        --port $PORT \
        $puma_options \
        >> ${log_directory}/puma.log 2>&1 &
      echo "verifying ..."
      sleep 4
      fetch_current_pid
      if [ "$current_pid" = 0 ]; then
        echo "ERROR: Process did not seem to start"
        exit 1
      else
        echo " running on pid ${current_pid}."
      fi
    else
      echo "Usage: $0 $1 <port*>"
      echo "  * PORT environmental variable can also be used to specify the port"
      exit 1
    fi
  fi
}

deploy() {
  <% if @jruby %>
  sudo monit restart all -g ${application}
  <% else %>
  for PORT in <%= @ports.join(' ') %>; do
    if is_running ; then
      echo "Hot deploying Puma for ${application} on port $PORT (pid: ${current_pid}) ..."
      cd ${current_path}
      pumactl -S ${pid_directory}/puma.$PORT.state restart && echo " hot deploy in progress."
    else
      start
    fi
  done
  <% end %>
}

stop() {
  if [ -z "$PORT" ] ; then
    echo "Usage: $0 $1 <port*>"
    echo "  * PORT environmental variable can also be used to specify the port"
    exit 1
  fi

  if is_running ; then
    echo "Stopping Puma for ${application} on port $PORT (pid: ${current_pid}) ..."
    kill ${current_pid} && echo " stopped." && cleanup
  else
    echo "ERROR: Cannot find a running process for ${application} on port $PORT"
    exit 1
  fi
}

case "$ACTION" in
  deploy)
    deploy
    ;;
  stop)
    stop
    ;;
  start)
    start
    ;;
  status)
    status
    ;;
  restart)
    deploy
    ;;
  *)
    echo "Usage: $0 {start|stop|status|restart|deploy} [<port>]"
    exit 1
    ;;
esac

exit 0
